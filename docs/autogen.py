from __future__ import unicode_literals

import re
import inspect
import os
import shutil

import sys
sys.path.append('..')

# Import all the modules from which you'll need to extract the documentation.
from jpeg_deep import displayer

# The path to the root of the git dir, will be used to setup the source for the functions.
git_path = "https://github.com/D3lt4lph4/pythondoc/tree/master/"

# The existing tags for the parsing of the source files are :
#   - all_functions_module: will details all the function in a module
#   - all_classes_module: will details all the functions in a module
#   - classes: will details the class/es as well as the available
#     methods inside the class
#   - functions: will detail the functions specified

# This are all the pages you need to generate on the fly from your documentation.
PAGES = [{
    'page': 'displayer/displayer.md',
    'autogenerated': [['all_classes_module', [displayer]]]
}]

# The root path of the gitlab
ROOT = 'https://github.com/D3lt4lph4/pythondoc'


def get_function_signature(function, method=True):
    """ Gets the signature of a given function.

    # Arguments:
        - function: The function to parse.
        - method: If this function is a class method. 
    
    # Return:
        The signature of the function.
    """
    wrapped = getattr(function, '_original_function', None)
    if wrapped is None:
        signature = inspect.getfullargspec(function)
    else:
        signature = inspect.getfullargspec(wrapped)

    # If this is a class method, ignore the self argument
    if method:
        args = signature.args[1:]
    else:
        args = signature.args

    # Getting the default values for the arguments
    defaults = signature.defaults
    annotations = signature.annotations
    varargs = signature.varargs
    varkw = signature.varkw

    if defaults:
        default_values = zip(args[-len(defaults):], defaults)
        args = args[:-len(defaults)]
    else:
        default_values = []

    # Get the full module for the function
    if not method:
        st = '%s.%s(' % (function.__module__, function.__name__)
    else:
        st = '%s(' % function.__name__

    for a in args:
        if annotations:
            st += str(a) + ": " + annotations[a].__name__ + ', '
        else:
            st += str(a) + ', '

    for a, v in default_values:
        if isinstance(v, str):
            v = '\'' + v + '\''
        if annotations:
            st += str(a) + ": " + annotations[a].__name__ + '=' + str(v) + ', '
        else:
            st += str(a) + '=' + str(v) + ', '

    if varargs is not None:
        st += "*args, "

    if varkw is not None:
        st += "**kwargs, "

    if default_values or args:
        signature = st[:-2] + ')'
    else:
        signature = st + ')'

    return signature


def get_class_signature(cls):
    try:
        class_signature = get_function_signature(cls.__init__)
        class_signature = class_signature.replace('__init__', cls.__name__)
    except (TypeError, AttributeError):
        # in case the class inherits from object and does not
        # define __init__
        class_signature = cls.__module__ + '.' + cls.__name__ + '()'
    return class_signature


def function_to_source_link(function):
    """ Create a markdown link to the function provided.
    
    # Argument:
        - The function we want the link to point to.

    # Return:
        A string with a link to the function in github.
    """

    # Get the path of the file holding the function
    module_name = function.__module__
    path = module_name.replace('.', '/')
    path += '.py'

    # Get the line of the function in the file
    line = inspect.getsourcelines(function)[-1]

    # Setting the link to the github file
    link = (git_path + path + '#L' + str(line))
    return '[[source]](' + link + ')'


def class_to_source_link(cls):
    """ Get the github source of the class.

    # Argument:
        - cls: The class of interest
    
    # Return:
        A string with the link to the source in github
    """
    # Get the path of the file holding the class
    module_name = cls.__module__
    path = module_name.replace('.', '/')
    path += '.py'

    # Get the line of the class in the file
    line = inspect.getsourcelines(cls)[-1]

    # Setting the link to the github file
    link = (git_path + path + '#L' + str(line))
    return '[[source]](' + link + ')'


def code_snippet(snippet):
    """ Adds the python code tags

    # Argument:
        - snippet: The code to have the tags around.

    # Return:
        The code with the tags.
    """
    result = '```python\n'
    result += snippet + '\n'
    result += '```\n'
    return result


def process_docstring(docstring):
    """ Process the docstring extrated from the object to parse. Mostly, set in bold the titles.

    # Argument:
        - The docstring to process

    # Return:
        The process docsctring

    """
    # First, extract code blocks and process them.
    code_blocks = []

    # If we have some code blocks in the documentation, extract them to avoid auto processing.
    if '```' in docstring:
        tmp = docstring[:]
        while '```' in tmp:
            tmp = tmp[tmp.find('```'):]
            index = tmp[3:].find('```') + 6
            snippet = tmp[:index]

            # Place marker in docstring for later reinjection.
            docstring = docstring.replace(snippet,
                                          '$CODE_BLOCK_%d' % len(code_blocks))
            snippet_lines = snippet.split('\n')

            # Remove leading and trailing spaces.
            num_leading_spaces = snippet_lines[-1].find('`')
            snippet_lines = ([snippet_lines[0]] +
                             [line[4:].rstrip() for line in snippet_lines[1:]])
            snippet_lines[-1] = snippet_lines[-1].strip()

            snippet = '\n'.join(snippet_lines)
            code_blocks.append(snippet)
            tmp = tmp[index:]

    # Format docstring section titles.
    docstring = re.sub(r'\n(\s+)# (.*)\n', r'\n\1__\2__\n\n', docstring)

    # Strip all leading spaces.
    lines = docstring.split('\n')
    docstring = '\n'.join([line.lstrip(' ') for line in lines])

    # Reinject code blocks.
    for i, code_block in enumerate(code_blocks):
        docstring = docstring.replace('$CODE_BLOCK_%d' % i, code_block)

    return docstring


def parse_function(function, indentation, method=False):
    """ Parse the function provided and set __doc__ argument as description.
    
    # Arguments:
        - function: The function to be parsed
        - indentation: The indentation that should be added at the begining of the function.
        - method: If the function to parse is a class method.
    
    # Returns:
        A string, the parsed function.
    """
    subblock = []

    # Get the signature of the function and set it as a header
    subblock.append('<span style="float:right;">' +
                    function_to_source_link(function) + '</span>')

    # We don't need the module for the header
    signature = get_function_signature(function, method=True)
    subblock.append(indentation + ' ' + function.__name__ + '\n')

    # We get the signature of the function and set it as python code
    signature = get_function_signature(function, method=method)
    subblock.append(code_snippet(signature))

    # Get the docstring and add it to the block of documentation
    docstring = function.__doc__

    if docstring:
        subblock.append(process_docstring(docstring))

    return subblock


def parse_class(cls, indentation):
    """ Parse the class documentation.
    
    # Arguments:
        - cls: The class to be parsed.
        - indentation: The type of indentation to use in the documentation
    
    # Return:
        The documentation string for the class.
    """

    subblock = []

    # We set the header for the class
    subblock.append('<span style="float:right;">' + class_to_source_link(cls) +
                    '</span>')
    subblock.append(indentation + ' ' + cls.__name__ + '\n')

    # We get the signature of the class and set it as python code
    signature = get_class_signature(cls)
    subblock.append(code_snippet(signature))

    # Get the docstring and add it to the block of documentation, we use the documentation of the init function
    docstring = cls.__init__.__doc__

    if docstring:
        subblock.append(process_docstring(docstring))

    return subblock


def fill_page(path, autogenerated_blocks):
    """ Open a file and replace the {{autogenerated}} text with what is inside the autogenerated_blocks list.

    # Arguments
        path: Path to the file to write.
        autogenerated_blocks: A list with the bunch of texts to be written.

    # Return
        A string with all data inside autogenerated_blocks written in it.
    """

    # First let's check if we have the correct number of tags for the length of our array.
    path = os.path.join('sources', page_name)
    with open(path) as f:
        mkdown = f.read()
        for autogenerated_block in autogenerated_blocks:
            mkdown = mkdown.replace('{{autogenerated}}', autogenerated_block,
                                    1)
        return mkdown


def parse_classes(to_be_detailled):
    """ Parse the to_be_detailled (a list of classes) and return a block with the corresponding documentation.

    # Arguments
        to_be_detailled: A list with all the classes to be detailled.

    # Return
        A string (block) with the documentation to be written.
    """
    blocks = []
    for detailled_class in to_be_detailled:
        # Parse the class
        subblock = parse_class(detailled_class, '##')
        blocks.append('\n\n'.join(subblock))

        # Parse the methods of the class
        for function in inspect.getmembers(detailled_class):
            # Ignoring the private functions
            if function[0][0] == '_':
                continue
            # Ignoring the properties
            if isinstance(function[1], property):
                continue
            subblock = parse_function(function[1], '###', method=True)
            blocks.append('\n\n'.join(subblock))
    return '\n***\n\n'.join(blocks)


def parse_all_classes_module(to_be_detailled):
    """ Parse the to_be_detailled (a module) and return a block with the corresponding documentation.

    # Arguments
        - to_be_detailled: A list, the module to be detailled.

    # Return
        A string (block) with the documentation to be written.
    """
    for module in to_be_detailled:
        blocks = []
        for name in dir(module):
            # If default function from python, skip
            if name[0] == '_':
                continue

            # Getting all the classes and more
            module_member = getattr(module, name)

            # Check to process only the classes
            if inspect.isclass(module_member):
                # Process the class
                class_to_parse = module_member
                if module.__name__ in class_to_parse.__module__:
                    subblocks = parse_class(class_to_parse, '##')
                    blocks.append('\n\n'.join(subblocks))
                    # Parse the methods of the class
                    for function in inspect.getmembers(class_to_parse):
                        # Ignoring the private functions
                        if function[0][0] == '_':
                            continue
                        # Ignoring the properties
                        if isinstance(function[1], property):
                            continue
                        subblock = parse_function(function[1],
                                                  '###',
                                                  method=True)
                        blocks.append('\n\n'.join(subblock))
    return '\n***\n\n'.join(blocks)


def parse_all_functions_module(to_be_detailled):
    """ Parse the to_be_detailled (a module) and return a block with the corresponding documentation.

    # Arguments
        - to_be_detailled: A list, the module to be detailled.

    # Return
        A string (block) with the documentation to be written.
    """
    for module in to_be_detailled:
        blocks = []
        for name in dir(module):
            # If default function from python, skip
            if name[0] == '_':
                continue

            # Getting all the functions and more
            module_member = getattr(module, name)

            # Check to process only the functions
            if inspect.isfunction(module_member):
                # Process the function
                function = module_member
                if module.__name__ in function.__module__:
                    subblocks = parse_function(function, '### ')
                    blocks.append('\n\n'.join(subblocks))
    return '\n***\n\n'.join(blocks)


def parse_functions(to_be_detailled):
    """ Parse all the function provided.

    # Argument:
        - to_be_detailled: A list of function to process.
    
    # Return:
        The blocks of processed functions.
    """
    blocks = []
    for function in to_be_detailled:
        subblocks = parse_function(function, '### ')
        blocks.append('\n\n'.join(subblocks))
    return '\n***\n\n'.join(blocks)


def initialize():
    """ First function ran in main, used to initialize the architecture of the documentation."""

    print('Cleaning up existing sources directory.')
    if os.path.exists('sources'):
        shutil.rmtree('sources')

    print('Populating sources directory with templates.')
    for subdir, dirs, fnames in os.walk('templates'):
        new_subdir = subdir.replace('templates', 'sources')
        if not os.path.exists(new_subdir):
            os.makedirs(new_subdir)
        for fname in fnames:
            if fname[-3:] == '.md':
                fpath = os.path.join(subdir, fname)
                new_fpath = fpath.replace('templates', 'sources')
                shutil.copy(fpath, new_fpath)

    # Initialize the index page with the README from the root directory
    readme = open('../README.md').read()
    index = open('templates/index.md').read()
    index = index.replace('{{autogenerated}}', readme)
    f = open('sources/index.md', 'w')
    f.write(index)
    f.close()


if __name__ == '__main__':

    # We generate all the source document files by copying the files from the template folder. Previously existing files will be removed.
    initialize()

    print('Starting autogeneration.')
    # For all the pages defined, we generate the documentation.
    for page_data in PAGES:

        # Will hold the blocks of generated data.
        autogenerated_blocks = []

        # First we check for the .md file to assert that we have the same number of '{{autogenerated}}' as we have entries in the pages' data. If the page is non-existing we generate a new one.
        page_name = page_data['page']
        path = os.path.join('sources', page_name)

        if os.path.exists(path):
            with open(path) as f:
                template = f.read()
                autogenerated_number = template.count('{{autogenerated}}')
                assert autogenerated_number == len(
                    page_data['autogenerated']
                ), ('Template found for ' + path +
                    ' but there is {} {{autogenerated}} tag for {} entries in the array in PAGES.'
                    .format(autogenerated_number,
                            len(page_data['autogenerated'])))
        else:
            autogenerated_number = len(page_data['autogenerated'])
            # Make the directory to write the file to if it does not already existing.
            subdir = os.path.dirname(path)
            if not os.path.exists(subdir):
                os.makedirs(subdir)
            # Generate the file if not existing with the correct number of autogenerated in it.
            with open(path, "w") as f:
                for _ in range(autogenerated_number):
                    f.write("{{autogenerated}}\n")

        # We extract the corresponding data for each existing tag.
        for tag, to_be_detailled in page_data['autogenerated']:
            if tag == 'classes':
                block = parse_classes(to_be_detailled)
            elif tag == 'functions':
                block = parse_functions(to_be_detailled)
            elif tag == "all_classes_module":
                block = parse_all_classes_module(to_be_detailled)
            elif tag == 'all_functions_module':
                block = parse_all_functions_module(to_be_detailled)
            else:
                raise RuntimeError("Wrong type of generation: {}".format(tag))

            # Append the generated blocks to the documentation
            autogenerated_blocks.append(block)

        # We replace all the {{autogenerated}} with the blocks
        to_write = fill_page(page_name, autogenerated_blocks)

        # Write the file
        print("Filling file : {}".format(path))
        open(path, 'w').write(to_write)
